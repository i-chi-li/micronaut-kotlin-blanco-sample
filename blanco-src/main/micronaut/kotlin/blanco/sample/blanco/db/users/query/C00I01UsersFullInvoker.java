/*
 * This code is generated by blanco Framework.
 */
package micronaut.kotlin.blanco.sample.blanco.db.users.query;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Date;

import micronaut.kotlin.blanco.sample.blanco.db.runtime.exception.DeadlockException;
import micronaut.kotlin.blanco.sample.blanco.db.runtime.exception.IntegrityConstraintException;
import micronaut.kotlin.blanco.sample.blanco.db.runtime.exception.NoRowModifiedException;
import micronaut.kotlin.blanco.sample.blanco.db.runtime.exception.TimeoutException;
import micronaut.kotlin.blanco.sample.blanco.db.runtime.exception.TooManyRowsModifiedException;
import micronaut.kotlin.blanco.sample.blanco.db.runtime.util.BlancoDbUtil;

/**
 * C00I01UsersFullInvokerクラス (QueryInvoker)。
 *
 * 実行型SQL文をラッピングして各種アクセサを提供します。<br>
 * シングル属性: 有効 (期待する処理件数は1件)<br>
 */
public class C00I01UsersFullInvoker {
    /**
     * このクラスが内部的に利用するデータベース接続オブジェクト。
     *
     * データベース接続オブジェクトはコンストラクタの引数として外部から与えられます。<br>
     * トランザクションのコミットやロールバックは、このクラスの内部では実行しません。
     */
    protected Connection fConnection;

    /**
     * このクラスが内部的に利用するステートメントオブジェクト。
     *
     * このオブジェクトはデータベース接続オブジェクトから生成されて内部的に利用されます。<br>
     * closeメソッドの呼び出し時に、このオブジェクトのcloseを実行します。
     */
    protected PreparedStatement fStatement;

    /**
     * C00I01UsersFullInvokerクラスのコンストラクタ。
     *
     * データベースコネクションオブジェクトを引数としてクエリクラスを作成します。<br>
     * このクラスの利用後は、必ず close()メソッドを呼び出す必要があります。<br>
     *
     * @param connection データベース接続
     */
    public C00I01UsersFullInvoker(final Connection connection) {
        fConnection = connection;
    }

    /**
     * SQL定義書で与えられたSQL文を取得します。
     *
     * SQL入力パラメータとして #キーワードによる指定がある場合には、該当箇所を ? に置き換えた後の SQL文が取得できます。
     *
     * @return JDBCドライバに与えて実行可能な状態のSQL文。
     */
    public String getQuery() {
        return "INSERT INTO users (\n  user_id,\n  user_name,\n  password,\n  email,\n  created_at,\n  updated_at\n) VALUES (\n  ?,\n  ?,\n  ?,\n  ?,\n  ?,\n  ?\n)";
    }

    /**
     * SQL定義書から与えられたSQL文をもちいてプリコンパイルを実施します。
     *
     * 内部的にConnection.prepareStatementを呼び出します。<br>
     *
     * @throws SQLException SQL例外が発生した場合。
     */
    public void prepareStatement() throws SQLException {
        close();
        prepareStatement(getQuery());
    }

    /**
     * 与えられたSQL文をもちいてプリコンパイルを実施(動的SQL)します。
     *
     * 動的に内容が変化するようなSQLを実行する必要がある場合にのみ、こちらのメソッドを利用します。<br>
     * そうではない場合には、このメソッドの利用は避けて prepareStatement()メソッド (引数なし)を呼び出してください。<br>
     * なぜなら、このメソッドではSQL文そのものをパラメータとして与えることができて自由度が高い一方、SQLインジェクションと呼ばれるセキュリティホールが発生する可能性を引き起こしてしまうからです。<br>
     * 内部的にConnection.prepareStatementを呼び出します。<br>
     *
     * @param query プリコンパイルを実施させたいSQL文。動的SQLの場合には、この引数には加工された後の実行可能なSQL文を与えます。
     * @throws SQLException SQL例外が発生した場合。
     */
    public void prepareStatement(final String query) throws SQLException {
        close();
        fStatement = fConnection.prepareStatement(query);
    }

    /**
     * SQL文に与えるSQL入力パラメータをセットします。
     *
     * 内部的には PreparedStatementにSQL入力パラメータをセットします。
     *
     * @param userId 'userId'列の値
     * @param userName 'userName'列の値
     * @param password 'password'列の値
     * @param email 'email'列の値
     * @param createdAt 'createdAt'列の値
     * @param updatedAt 'updatedAt'列の値
     * @throws SQLException SQL例外が発生した場合。
     */
    public void setInputParameter(final Integer userId, final String userName, final String password, final String email, final Date createdAt, final Date updatedAt) throws SQLException {
        if (fStatement == null) {
            prepareStatement();
        }
        if (userId == null) {
            fStatement.setNull(1, java.sql.Types.INTEGER);
        } else {
            fStatement.setInt(1, userId.intValue());
        }
        fStatement.setString(2, userName);
        fStatement.setString(3, password);
        fStatement.setString(4, email);
        if (createdAt == null) {
            fStatement.setNull(5, java.sql.Types.TIMESTAMP);
        } else {
            fStatement.setTimestamp(5, new Timestamp(createdAt.getTime()));
        }
        if (updatedAt == null) {
            fStatement.setNull(6, java.sql.Types.TIMESTAMP);
        } else {
            fStatement.setTimestamp(6, new Timestamp(updatedAt.getTime()));
        }
    }

    /**
     * SQL文を実行します。
     *
     * シングル属性が有効なのでスコープをprotectedとします。<br>
     * このメソッドの代わりに executeSingleUpdateメソッドを利用してください。<br>
     *
     * @return 処理された行数
     * @throws IntegrityConstraintException データベース制約違反が発生した場合。
     * @throws DeadlockException データベースデッドロックが発生した場合。
     * @throws TimeoutException データベースタイムアウトが発生した場合。
     * @throws SQLException SQL例外が発生した場合。
     */
    protected int executeUpdate() throws IntegrityConstraintException, DeadlockException, TimeoutException, SQLException {
        if (fStatement == null) {
            // PreparedStatementが未取得の状態なので、PreparedStatement.executeUpdate()実行に先立ちprepareStatement()メソッドを呼び出して取得します。
            prepareStatement();
        }

        try {
            return fStatement.executeUpdate();
        } catch (SQLException ex) {
            throw BlancoDbUtil.convertToBlancoException(ex);
        }
    }

    /**
     * SQL文を実行します。
     *
     * SQL文の実行結果が1行であることを確認します。実行結果が1行以外である場合には例外を発生させます。<br>
     * シングル属性が有効となっているので生成されます。<br>
     *
     * @throws NoRowModifiedException データベースの処理の結果、1行もデータが変更されなかった場合。
     * @throws TooManyRowsModifiedException データベースの処理の結果、1行を超えるデータが変更されてしまった場合。
     * @throws IntegrityConstraintException データベース制約違反が発生した場合。
     * @throws DeadlockException データベースデッドロックが発生した場合。
     * @throws TimeoutException データベースタイムアウトが発生した場合。
     * @throws SQLException SQL例外が発生した場合。
     */
    public void executeSingleUpdate() throws NoRowModifiedException, TooManyRowsModifiedException, IntegrityConstraintException, DeadlockException, TimeoutException, SQLException {
        int result = 0;
        result = executeUpdate();

        if (result == 0) {
            throw new NoRowModifiedException("データベースの処理の結果、1行もデータが変更されませんでした。");
        } else if (result > 1) {
            String message = "データベースの処理の結果、1行を超えるデータが変更されました。変更件数:" + result;
            throw new TooManyRowsModifiedException(message);
        }
    }

    /**
     * ステートメント (java.sql.PreparedStatement) を取得します。
     * @deprecated 基本的にStatementは外部から直接利用する必要はありません。
     *
     * @return 内部的に利用されている java.sql.PreparedStatementオブジェクト
     */
    public PreparedStatement getStatement() {
        return fStatement;
    }

    /**
     * このクラスのクローズ処理をおこないます。
     *
     * 内部的に生成していたJDBCリソースのオブジェクトに対して close()メソッドの呼び出しをおこないます。<br>
     * クラスの利用が終わったら、必ずこのメソッドを呼び出すようにします。
     *
     * @throws SQLException SQL例外が発生した場合。
     */
    public void close() throws SQLException {
        if (fStatement != null) {
            fStatement.close();
            fStatement = null;
        }
    }

    /**
     * finalizeメソッド。
     *
     * このクラスが内部的に生成したオブジェクトのなかで、close()呼び出し忘れバグが存在するかどうかチェックします。<br>
     *
     * @throws Throwable finalize処理の中で発生した例外。
     */
    protected void finalize() throws Throwable {
        super.finalize();
        if (fStatement != null) {
            final String message = "C00I01UsersFullInvoker : close()メソッドによるリソースの開放が行われていません。";
            System.out.println(message);
        }
    }
}
